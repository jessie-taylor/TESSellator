# Now requires a subdirectory in scripts dir named OutputArrays
#import numpy as np
#import matplotlib.pyplot as plt
#import os
#from PIL import Image
#from datetime import datetime
#CompleteArray =np.empty([480, 640, 0])
#NameArray = []  # ADDED FOR NAMING
#total_i = 0
#dir = 'binaries_training_set/'
#for subdirectories, dirs, files in os.walk(dir):
#  i = 0
#  for subdir in dirs:
#    try:
#      print('On file', total_i, '/', len(dirs))
#      i = i + 1
#      total_i = total_i + 1 #counting total number for recording
#      timehere = datetime.now() # getting time now
#      spectra = np.loadtxt(dir+subdir+'/s000000.dat')
#      NameArray.append(subdir[:-18]) # ADDED FOR NAMING
#      plt.plot(spectra[:, 0], spectra[:, 1])
#      if (np.max(spectra[:,1]) <=500):
#        plt.ylim(0,500)
#      plt.savefig('graph.png')
#      ImageArray = Image.open('graph.png')
#      image2 =ImageArray.convert('L')
#      ArrayAppender =np.asarray(image2, dtype="int32")
#      CompleteArray =np.dstack((ArrayAppender, CompleteArray))
#      plt.clf()
#    except:
#      pass
#    if i == 1000:
#      #naming array with which i it goes to from the last
#      arrayname = 'OutputArrays/' + dir[:-1] + '_' + str(total_i) + '.npy'       
#      np.save(arrayname, CompleteArray) #save array every 1000 files
#      np.save(arrayname[:-4] + '_names.npy', NameArray)  # ADDED FOR NAMING
#      CompleteArray = np.empty([480, 640, 0]) #clear array that's just been saved
#      NameArray = [] # Clearing naming array
#      i = 0 #reset number to 0
#    print('time to complete loop =', datetime.now()-timehere) #print time to loop
#    
#print(CompleteArray.shape)
#np.save('OutputArrays/' + dir[:-1] + '_' + str(total_i) + '.npy', CompleteArray) #save remaining files
#np.save('OutputArrays/' + dir[:-1] + '_' + str(total_i) + '_names.npy', NameArray)  # ADDED FOR NAMING

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Rewriting for TESS data in 2023
# Keep all import stuff from above (lines 2 - 6)
from KEBC.get_ebs import ebs
from get_dfts import get_dfts

# First, gather the ids of one catalog using the kebc module ebs()
# Then send the list of IDs to get_dfts to obtain a dataframe of the DFTs & IDs
# Put them into arrays using the method from the original version of arraymaker
# Save arrays in ./arrays
import numpy as np
import matplotlib.pyplot as plt
import os
from PIL import Image
from datetime import datetime
import lightkurve as lk

# function for getting dfts from get_dfts
# and putting them in arrays
# Made as a function so it can be called for each of the catalogues
def make_array(ids: list, catname: str):
  """
  Uses lists of IDs generated from catalog modules
  to obtain DFTs, and plot those to generate arrays
  for use in a CNN.

  Parameters
  ----------
  ids : list
      List of TIC IDs, generated by individual catalog modules.
      Must be added as only numbers, no "TIC" preamble.
      TIC ID expected as str.
  catname : str
      Name of catalog ids is associated with.
      This determines the filename of generated array.

  Yields
  ------
  complete_array : np.array                      [MIGHT BE WRONG HERE - CHECK]
      Numpy array generated and saved with name
      corresponding to catname input string.
  """
  namearray = []
  completearray = np.empty([480, 640, 0])
  total_i = 0
  i = 0

  # Remove ids that come up as None using a filter
  print ("Removing Nones from list. Length of list before filtering:", 
         len(ids))
  idsfiltered = filter(lambda item: item is not None, ids)
  ids = list(idsfiltered)
  print ("Nones removed, new length of TIC ID list:", len(ids))


  # obtain DFTs from list of IDs
  stars_data = get_dfts(ids)
  
  
  # Using each ID to loop through each star in the dictionary
  # [ might want to add an exception if no data was found 
  # but see where the error pops up first
  for starid in ids:
    print('On star', total_i, '/', len(ids))
    # Counting total number for recording
    i = i + 1
    total_i = total_i + 1
    # Get the time now, for seeing how long each iteration takes
    timehere = datetime.now()

    # Try/Except in case no dft available for star
    try:
      # Obtain the dft for this star
      dft = stars_data[str(starid) + "_dft"]
    # If no DFT available
    except KeyError:
      print ("Skipped", starid, "due to no available LC data")
      continue
    
    # Add name to namearray for keeping track of which star is which
    namearray.append(starid)

    # for plotting, can get frequency with dft.frequency
    # can also obtain period and power the same way 
    plt.plot(dft.frequency, dft.power)
    plt.ylim(-1, 500)
    plt.savefig("arraymakingplot_deleteaftercomplete.png")
    
    # Add image to array
    imagearray = Image.open('arraymakingplot_deleteaftercomplete.png')
    image2 =imagearray.convert('L')
    arrayappender =np.asarray(image2, dtype="int32")
    completearray =np.dstack((arrayappender, completearray))
    plt.clf()

    # Save array if it gets to 1000 entries, to avoid memory issues
    if i == 1000:
      # Naming array with which stars it contains
      arrayname = "arrays/" + catname + "_" + str(total_i) + ".npy"
      # Save array of plots
      np.save(arrayname, completearray)
      # Save array of names
      np.save(arrayname[:-4] + '_names.npy', namearray)
      # Clear array ready for next 1000
      completearray = np.empty([480, 640, 0])
      namearray = []
      # Reset to keep track of how many are in next array
      i = 0
    # To keep track of how long things take - print time taken
    print('time to complete loop =', datetime.now()-timehere)
    
  print(completearray.shape)
  np.save('arrays/' 
          + catname 
	  + '_' 
	  + str(total_i) 
	  + '.npy', completearray) #save remaining files
  np.save('arrays/' 
          + catname 
	  + '_' 
	  + str(total_i) 
	  + '_names.npy', namearray)  # ADDED FOR NAMING

 
# outside of function - call on make_array to generate arrays
# for each one of the catalogs

# Obtain list of EB TICs 
eb_ids = ebs()
# Obtain data for stars in EB TICs (given as dictionary) ~~~~~~~~~~~~~~~~~~~~~~Currently only first 100 for speed of testing
# this str([TIC id] + "_lc") is the dictionary key the lightcurves are under
# this str([TIC id] + "_dft") is the key for the dfts
# ebs_data = get_dfts(eb_ids[0:1])
# Save a backup of the data
# So doesn't need to be redownloaded if needed later
#for star in eb_ids:
#  # Put in try/except because not all IDs are going to have lcs associated
#  try:
#    # Obtain lc from dictionary key
#    lc = ebs_data[str(star + "_lc")]
#    # Save lc to FITS file
#    lc.to_fits(path = str("./FITS/" + star + ".fits"),
#               overwrite = True)
#  # If no TIC found (ie entry in eb_ids = None)
#  except TypeError:
#    continue
#  # If no corresponding lc
#  except KeyError:
#    continue
# Make and save arrays for data ------------------------------------ONLY NEEDS TO BE IDS, STUFF FROM BEFORE CAN BE MOVED ELSEWHERE
make_array(eb_ids, "ebs") #--------------------------------------------------- FIRST 100 FOR TESTING ONLY

# EXTRA INFO IS IN lc.meta, such as the TEFF etc, which will be useful later
# It's a dictionary, so can use lc.meta["TEFF"] etc
# This info is also still retained in the dft
