# Now requires a subdirectory in scripts dir named OutputArrays
#import numpy as np
#import matplotlib.pyplot as plt
#import os
#from PIL import Image
#from datetime import datetime
#CompleteArray =np.empty([480, 640, 0])
#NameArray = []  # ADDED FOR NAMING
#total_i = 0
#dir = 'binaries_training_set/'
#for subdirectories, dirs, files in os.walk(dir):
#  i = 0
#  for subdir in dirs:
#    try:
#      print('On file', total_i, '/', len(dirs))
#      i = i + 1
#      total_i = total_i + 1 #counting total number for recording
#      timehere = datetime.now() # getting time now
#      spectra = np.loadtxt(dir+subdir+'/s000000.dat')
#      NameArray.append(subdir[:-18]) # ADDED FOR NAMING
#      plt.plot(spectra[:, 0], spectra[:, 1])
#      if (np.max(spectra[:,1]) <=500):
#        plt.ylim(0,500)
#      plt.savefig('graph.png')
#      ImageArray = Image.open('graph.png')
#      image2 =ImageArray.convert('L')
#      ArrayAppender =np.asarray(image2, dtype="int32")
#      CompleteArray =np.dstack((ArrayAppender, CompleteArray))
#      plt.clf()
#    except:
#      pass
#    if i == 1000:
#      #naming array with which i it goes to from the last
#      arrayname = 'OutputArrays/' + dir[:-1] + '_' + str(total_i) + '.npy'       
#      np.save(arrayname, CompleteArray) #save array every 1000 files
#      np.save(arrayname[:-4] + '_names.npy', NameArray)  # ADDED FOR NAMING
#      CompleteArray = np.empty([480, 640, 0]) #clear array that's just been saved
#      NameArray = [] # Clearing naming array
#      i = 0 #reset number to 0
#    print('time to complete loop =', datetime.now()-timehere) #print time to loop
#    
#print(CompleteArray.shape)
#np.save('OutputArrays/' + dir[:-1] + '_' + str(total_i) + '.npy', CompleteArray) #save remaining files
#np.save('OutputArrays/' + dir[:-1] + '_' + str(total_i) + '_names.npy', NameArray)  # ADDED FOR NAMING

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# Rewriting for TESS data in 2023
# Keep all import stuff from above (lines 2 - 6)
from KEBC.get_ebs import ebs
from get_dfts import get_dfts

# First, gather the ids of one catalog using the kebc module ebs()
# Then send the list of IDs to get_dfts to obtain a dataframe of the DFTs & IDs
# Put them into arrays using the method from the original version of arraymaker
# Save arrays in ./arrays
import numpy as np
import matplotlib.pyplot as plt
import os
from PIL import Image
from datetime import datetime
import lightkurve as lk

CompleteArray = np.empty([480, 640, 0])
NameArray = []
total_i = 0
 
# function for getting dfts from get_dfts
# and putting them in arrays
# Made as a function so it can be called for each of the catalogues
def make_array(ids: list, catname: str):
  """
  Uses lists of IDs generated from catalog modules
  to obtain DFTs, and plot those to generate arrays
  for use in a CNN.

  Parameters
  ----------
  ids : list
      List of TIC IDs, generated by individual catalog modules.
      Must be added as only numbers, no "TIC" preamble.
      TIC ID expected as str.
  catname : str
      Name of catalog ids is associated with.
      This determines the filename of generated array.

  Yields
  ------
  complete_array : np.array                      [MIGHT BE WRONG HERE - CHECK]
      Numpy array generated and saved with name
      corresponding to catname input string.
  """
  # obtain df of DFTs from list of IDs
  dftdf = get_dfts(ids)
  
  #
  
# outside of function - call on make_array to generate arrays
# for each one of the catalogs

# Obtain list of EB TICs 
eb_ids = ebs()
# Obtain data for stars in EB TICs (given as dictionary) ~~~~~~~~~~~~~~~~~~~~~~Currently only first 20 for speed of testing
# str([TIC id] + "_lc") is the dictionary key the lightcurves are under
# str([TIC id] + "_dft") is the key for the dfts
ebs_data = get_dfts(eb_ids[0:20])
# Save a backup of the data
# So doesn't need to be redownloaded if needed later
# can use lc.to_fits(path='FITS_PATH.fits', overwrite = True) and make it use the names of the files
for star in eb_ids:
  # Put in try/except because not all IDs are going to have lcs associated
  try:
    # Obtain lc from dictionary key
    lc = ebs_data[str(star + "_lc")]
    # Save lc to FITS file
    lc.to_fits(path = str("./FITS/" + star + ".fits"),
               overwrite = True)
  except KeyError:
    continue
# Make and save arrays for data
make_array(ebs_data, "ebs")

